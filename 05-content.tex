\newcommand{\orgmode}{\texttt{org-mode}}
\newcommand{\Makefile}{\mintinline{shell}{Makefile}}
\newcommand{\context}{\mintinline{shell}{context}}
\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}
\newcommand{\qmcchem}{\textsc{QMC=Chem}}
\newcommand{\champ}{\textsc{Champ}}
\newcommand{\turbo}{\textsc{TurboRVB}}
\newcommand{\QMCkl}{\textsc{\ac{QMCkl}}}

\section{Introduction}

There are three different \ac{QMC} codes in the \ac{TREX} \ac{CoE},
\qmcchem{}, \turbo{}, and \champ{}, each with its own strengths and
weaknesses. Instead of optimizing the three codes independently for
exascale architectures, or re-writing a new monolithic code, our
strategy is instead to design a new library, \QMCkl{}, containing
the best of each code. The functions available in this library will
allow all three codes to benefit from the optimal implementations of
the major kernels of \ac{QMC}. We hope that this library will be
adopted by the community beyond the \ac{TREX} \ac{CoE}.

The three main objectives driving the development of \QMCkl{} are
\emph{performance}, \emph{productivity} and \emph{portability}.

\subsection{Performance}

The ultimate goal of \QMCkl{} is to provide a high-performance
implementation of the main computational kernels involved in \ac{QMC}
methods, well adapted to exascale machines.
In this particular \ac{WP}, we focus on the
definition of the \ac{API}, the tests, and on a \emph{pedagogical}
presentation of the algorithms. The high-performance aspects are
delegated to \ac{WP}3, but there is nevertheless a strong interaction
between these two \acp{WP} because the design of the data structures
and the \ac{API} are guided by the possibility to enable a
high-performance implementation of the computational kernels.
For instance, the data structures should be such that the memory
access patterns are efficient both on CPUs and accelerators, and the
library should not be too restrictive on how the memory is allocated
to give enough freedom to the developers of the \ac{HPC} variants to
allocate memory on the CPU or \ac{GPU}, pinned or not, etc.

The main objective of this pedagogical implementation of the library
is to provide a reference implementation of the kernels such that
\ac{HPC} experts will be able to use it to rewrite optimized versions
of the functions described in this library, using the same \ac{API}.

\subsection{Portability}

\QMCkl{} should take advantage of exascale machines. In terms of hardware,
many different architectural designs are proposed for exascale
supercomputers. Some are CPU-based, others are \ac{GPU}-based, multiple vendors
propose different CPUs (Intel, AMD, ARM,~\dots) or \acp{GPU} (Intel,
NVidia, AMD,~\dots). In this context, we have to propose a library that
will take advantage of any of these combinations so we can't rely on 
a vendor-specific software stack like Intel's \ac{MKL} or Nvidia's
Cuda language. Instead, we
will rely on free software and standards such as OpenMP, but the BSD
licence we have adopted also gives the freedom to the community to
modify \QMCkl{} and propose vendor-specific implementations.

For maximum portability, we have chosen to write the library in the C
language. In this way, we guarantee that \QMCkl{} will be usable in
\emph{all} the QMC codes used by the \ac{QMC} community, although these
codes are written in different programming languages (C, C++, Python,
Fortran, etc.).

\subsection{Productivity}

\ac{QMC} methods are still under heavy development. Therefore,
scientists need to be able to understand the code to modify the
algorithms and propose new methods. It is not realistic to believe
that any physicist/chemist will be able to read and develop a highly optimized
C++ code tuned by \ac{HPC} experts. Similarly, it is not realistic
either to believe that a code written by a random physicist/chemist will
be be easily ported to \ac{GPU} by a \ac{HPC} expert without breaking deeply the
structure of the code. If a compromise
is chosen between these two extremes, it is likely that it will
converge to a code difficult to maintain by the physicist and
difficult to optimize by the \ac{HPC} expert. Therefore our choice was to
develop at least two libraries with the same \ac{API}: first a
\emph{pedagogical} implementation (the objective of the current \ac{WP})
designed for physicists/chemists, and then multiple high-performance
implementations of this library.

\section{Design of the library}

\subsection{Literate programming}

As the focus of this library is documentation, we use literate
programming using {\orgmode} files.\cite{schulte_2012,orgmode}
Hence, the code and the documentation are produced with the same
source files, allowing the programmers to write \LaTeX{} formulas and
use tables or figures together with the corresponding code in the same
files.
This method has proven to be particularly efficient in maintaining the
documentation consistent with the source code, and literate
programming is now becoming a very popular technique thanks to the
development of Jupyter notebooks.
Here, we have chosen {\orgmode} as it allows the simultaneous usage of
multiple languages in the same notebook, and also doesn't impose to
use a web browser for editing.

\subsection{Configuration}

In the first months, a large effort was put in preparing the
foundations of the library: the coding standards and rules, GNU Autotools
configuration scripts, Makefiles, scripts to generate automatically
the code and the documentation, unit testing, continuous integration,
etc. It is important not to neglect the importance of all these
developments which are not directly visible from outside of the project.
Having spent a large effort of preparation pays a lot in the long term
since is can dramatically enhance the productivity of the contributors
of the library.
Now that this effort has been done, we are in a position where we can
are highly productive in implementing new kernels.

\section{Implemented kernels}

In the last few months, the majority of the effort was put in
implementing and documenting kernels. Our objective for this milestone
was to provide a library that is capable of computing the local energy
(the central quantity in \ac{QMC}) for any arbitrary system described
by a Slater determinant using a Gaussian atomic basis set. We have
reached successfully this stage, and the implemented kernels are
described in this section.

The documentation of the current status of the library is available
at \url{https://trex-coe.github.io/qmckl}, and the source code is
available on the GitHub repository at \url{https://github.com/trex-coe/qmckl}.

% TODO: KERNELS HERE
\subsection{Native linear algebra functions}

One of the main development guidelines is to maximize the use
of \ac{BLAS} like operations in the main kernels. The main \ac{BLAS} operations are
categorized into three types in order of increasing efficiency:

\begin{itemize}
\item Level 1 - Operations for e.g. scalar product on two vectors.
\item Level 2 - Operations involving a Matrix and a vector (e.g. Matrix vector product).
\item Level 3 - Operations involving two matrices (e.g. Matrix times Matrix).
\end{itemize}

Incorporating these basic operations in developing the main algorithms is key to
acheive an optimal implementation of the kernels. However, these key BLAS
functions depend on the type of hardware (i.e. CPU, GPU, or FPGA) and require a
tailored approach. Therefore, in \ac{QMCkl}, we have chosen to abstract the
calls to such libraries with standard \ac{QMCkl} functions such as
\mintinline{C}{qmckl_dgemm} and \mintinline{C}{qmckl_invert}. This has a
two-fold advantage of standardizing the API and enabling hardware specific
optimizations by HPC experts without breaking user-space.

A second and significant advantage of providing native implementations of
such key functions is to enable new developers and scientists to easily
setup and install a minimal version of \ac{QMCkl} without struggling with
a large set of dependencies. Thus enabling easy adaptations by new users.

\subsection{Molecular orbitals}

The calculation of molecular orbitals (MOs) is one such key kernel which can
become a bottleneck unless one uses a highly optimized implementation.
In this documentation implementation, we have provided an extremely simple
algorithm which uses \ac{BLAS} Level 3 call (\mintinline{C}{qmckl_dgemm})
as shown below.

\begin{equation}
  \phi_i(r) = \sum_{j}C_{i,j}\xi_j(r)
\end{equation}

Thus enabling HPC experts to easily identify and optimize the calculation
of MOs. Note that in the documentation library, the
calculation of the MOs uses a native call to the \mintinline{C}{qmckl_dgemm}
function. It will also help the HPC experts to identify possible
use of sparse data structures by realizing that the Atomic orbitals (AOs)
are usually very sparse. Thus enabling a gain in performance from $\mathcal{O}(n^3)$
to $\mathcal{O}(n)$ in copmexity of the computation.

\subsection{Slater Determinant}

Once the molecular orbitals are implemented, the slater matrix needs to be
calculated along with its inverse. Here again we encounter a standard
\ac{LAPACK} function \mintinline{C}{qmckl_invert} for which we have also
provided a small native library. An efficient implementation of the inverse is
key to avoid an $N^3$ scaling of the algorithm. We have specially provided hand
coded functions for the calculation of inverse of small matrices ($M\le 5$) in
order to avoid the overhead of call to external libraries. Efficient methods
based on the adjoint of a matrix \cite{MCMQC} have been used to avoid the
unnecessary calculation of the determinant at every Monte-Carlo step.
Here, we shall also show interaction with another kernel which implements
efficient algorithm for updating the inverse of a matrix (Sherman-Morrison updates)
without recalculating the inverse. However, the calculation of the
exact inverse is also available if required.

\subsection{Local energy}

The central quantity in any QMC code is the local energy irrespective of
the algirithm. Thus, an efficient implementation is desirable. Once again
the use of \ac{BLAS} based calls, have been used to implenent the calculation
of the kinetic energy which is the key components. For this purpose, a
special function \mintinline{C}{qmckl_dgemm_diag} has been used which
provides the diagonal of a Level 3 matrix product. Thus enabling optimization
by HPC experts of this key kernel.

\subsection{Drift vector}

The drift vector is also a key step in \ac{QMC} algorithms and
involves an expensive calculation of the adjoint of the slater matrix.
The drift vector requires the gradient of the MOs along the three
spatial directions. This also translates to a call to \mintinline{C}{qmckl_dgemm_diag} function.

\subsection{Introduction of TREXIO in QMCkl}

The input of a \ac{QMC} calculation is a wave function, which
contains usually a large number of parameters of different nature:
nuclear coordinates, atomic basis set parameters, pseudo-potential
parameters, molecular orbital coefficients, Slater determinant
expansion, etc.
Hence, initializing \QMCkl{} can quickly become cumbersome.

\ac{TREXIO} is the file format and input/output library developed in
\ac{WP}2. It allows to store all the information relative to a wave
function in a file, and provides functions to retrieve easily all
these parameters. 

To simplify the initialization procedure of the library, we have
introduced the possibility to load in a single function call all the
wave function parameters contained in a \ac{TREXIO} file. This simple
change is extremely beneficial to the user experience.


\section{Applications of QMCkl}

The proposed library can already be used in production and for
methodological developments. A few examples are presented in this section.

\subsection{Jastrow factor in QMC=Chem}

The strength of \qmcchem{} is large multi-determinant expansions, so very
little effort was put in the development of the Jastrow factor. Only the
simplest form of Jastrow factor was initially available. As shown above, the
sophisticated form of Jastrow factor developed in \champ{} was introduced
in \QMCkl{}, so this functionality has been made quickly available
in \qmcchem{}.

\subsection{Sherman-Morrison-Woodbury kernels in QMC=Chem}

The Sherman-Morrison-Woodbury formula is the most important kernel in
simulations involving large multi-determinant expansions. Hence, it has
been carefully optimized in \qmcchem{} in the past. The kernels
developed in \QMCkl{} were introduced in \qmcchem{} in order
to compare the performance of the library with \qmcchem{}. The
comparisons are still ongoing, but is now easy to measure the
efficiency of the kernels developed in \QMCkl{} since we can now
measure their efficiency beyond benchmark situations, under real
simulation conditions.

\subsection{Exploratory methods using neural networks}

In \ac{WP}4, one project consists in using a neural network as a
form of Jastrow factor. Many frameworks for machine learning are in
Python or Java, which can't be easily used inside a Fortran program.
Moreover, for this particular project we need to evaluate the gradient
and Laplacian of the Jastrow factor, which requires the ability to
compute derivatives of the neural network. Computing derivatives is
particularly easy with the PyTorch package which is for the Python
programming language. In this project, we will use Python as the main
language, PyTorch for the neural network and \QMCkl for the
Slater-determinant component. This project will illustrate the
versatility of \QMCkl, and the importance of providing a library that
can be easily used in any programming language.


\subsection{Exascale-related algorithms}

Another project of \ac{WP}4 is the development of a novel algorithm
for \ac{DMC}, enabling an efficient load-balancing by
making the walkers de-synchronized. In this particular work, it is only
necessary to have a ``black box'' that computes the local energy and
the gradient of the wave function, which can be both provided by \QMCkl{}.
This work will first be realized in the Julia or in the Python
language, which are very good for quick prototyping, and then once the
algorithm is validated on a large scale it will be implemented in the
flagship codes.


\subsection{Debugging TREXIO files}

We expect the \ac{TREXIO} library to be widely adopted by the community of
quantum chemistry. but writing files in \ac{TREXIO} format requires the developer
to be well aware of the conventions used in the code, namely the normalization factors
of the basis functions, the order in which the Cartesian functions appear, etc.
It is important to provide a tool with \ac{TREXIO}, that will allow the developer to
check that the file written is valid. A good check is to very numerically that the
molecular orbitals are orthonormal. Passing this test implies that the data
relative to the basis set is consistent with the coefficients of the molecular
orbitals, so the \ac{TREXIO} file is valid.

\section{Future work}

\subsection{Development}

We have now reached a milestone where we are able to compute the local energy of an
arbitrary system described as a single determinant with a Gaussian basis set.
Reaching this stage enables the development of \ac{HPC} variants of the library in
\ac{WP}3, and the exploratory benchmarks to monitor the performance of the kernels on
CPUs and \acp{GPU} as well as the efficiency in the way they are scheduled.
However, there is still a lot of work to do in this \ac{WP} to make \QMCkl{}
usable by external developers.

The most important kernels that need to be implemented are:
\begin{itemize}
  \item Kernels related to \ac{ECP}
  \item Multi-determinant wave functions
  \item Different forms of Jastrow factors
  \item Atomic basis functions input as values on grid points, to enable the use of
        arbitrary forms of atomic orbitals
  \item Cusp-fitting of the molecular orbitals at the nuclear positions
  \item Kernels related to periodic calculations
\end{itemize}

\subsection{Applications}

\newcommand{\qp}{\textsc{Quantum Package}}

We plan in the future to finish the integration of \QMCkl{} into the \ac{QMC}
codes of the \ac{CoE}. The efficient evaluation of the molecular orbitals is
now a performance bottleneck in \turbo{} that will be solved by using the
\ac{HPC} implementations of \QMCkl{}. Similarly, the three-body component of
the Jastrow factor in \champ{} will be accelerated by using \QMCkl{}.

Other applications of the library are possible beyond \ac{QMC}. For instance, 
the \qp{} code allows to combine \ac{DFT} with wave function
methods. \ac{DFT} methods require the computation of the one-electron density on 
a grid since many important integrals can only be approximated numerically. We
plan to use \QMCkl{} in \qp{} to accelerate the computation of the density grids
to demonstrate the potential of the library.


%% TODO : I am here

\clearpage


